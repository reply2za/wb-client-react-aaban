{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst FileCoverage = require('./file').FileCoverage;\n\nconst CoverageSummary = require('./file').CoverageSummary;\n\nfunction loadMap(source) {\n  const data = Object.create(null);\n  Object.keys(source).forEach(k => {\n    const cov = source[k];\n\n    if (cov instanceof FileCoverage) {\n      data[k] = cov;\n    } else {\n      data[k] = new FileCoverage(cov);\n    }\n  });\n  return data;\n}\n/**\n * CoverageMap is a map of `FileCoverage` objects keyed by file paths.\n * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n * map's contents. This can be the raw global coverage object.\n * @constructor\n */\n\n\nfunction CoverageMap(obj) {\n  if (!obj) {\n    this.data = Object.create(null);\n  } else if (obj instanceof CoverageMap) {\n    this.data = obj.data;\n  } else {\n    this.data = loadMap(obj);\n  }\n}\n/**\n * merges a second coverage map into this one\n * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n *  correctly for the same files and additional file coverage keys are created\n *  as needed.\n */\n\n\nCoverageMap.prototype.merge = function (obj) {\n  let other;\n\n  if (obj instanceof CoverageMap) {\n    other = obj;\n  } else {\n    other = new CoverageMap(obj);\n  }\n\n  Object.keys(other.data).forEach(k => {\n    const fc = other.data[k];\n\n    if (this.data[k]) {\n      this.data[k].merge(fc);\n    } else {\n      this.data[k] = fc;\n    }\n  });\n};\n/**\n * filter the coveragemap based on the callback provided\n * @param {Function (filename)} callback - Returns true if the path\n *  should be included in the coveragemap. False if it should be\n *  removed.\n */\n\n\nCoverageMap.prototype.filter = function (callback) {\n  Object.keys(this.data).forEach(k => {\n    if (!callback(k)) {\n      delete this.data[k];\n    }\n  });\n};\n/**\n * returns a JSON-serializable POJO for this coverage map\n * @returns {Object}\n */\n\n\nCoverageMap.prototype.toJSON = function () {\n  return this.data;\n};\n/**\n * returns an array for file paths for which this map has coverage\n * @returns {Array{string}} - array of files\n */\n\n\nCoverageMap.prototype.files = function () {\n  return Object.keys(this.data);\n};\n/**\n * returns the file coverage for the specified file.\n * @param {String} file\n * @returns {FileCoverage}\n */\n\n\nCoverageMap.prototype.fileCoverageFor = function (file) {\n  const fc = this.data[file];\n\n  if (!fc) {\n    throw new Error('No file coverage available for: ' + file);\n  }\n\n  return fc;\n};\n/**\n * adds a file coverage object to this map. If the path for the object,\n * already exists in the map, it is merged with the existing coverage\n * otherwise a new key is added to the map.\n * @param {FileCoverage} fc the file coverage to add\n */\n\n\nCoverageMap.prototype.addFileCoverage = function (fc) {\n  const cov = new FileCoverage(fc);\n  const path = cov.path;\n\n  if (this.data[path]) {\n    this.data[path].merge(cov);\n  } else {\n    this.data[path] = cov;\n  }\n};\n/**\n * returns the coverage summary for all the file coverage objects in this map.\n * @returns {CoverageSummary}\n */\n\n\nCoverageMap.prototype.getCoverageSummary = function () {\n  const ret = new CoverageSummary();\n  this.files().forEach(key => {\n    ret.merge(this.fileCoverageFor(key).toSummary());\n  });\n  return ret;\n};\n\nmodule.exports = {\n  CoverageMap\n};","map":{"version":3,"sources":["/Users/zainaaban/Documents/Northeastern/nf20/CS4550/cs4550-f20-client-react-aaban/node_modules/istanbul-lib-coverage/lib/coverage-map.js"],"names":["FileCoverage","require","CoverageSummary","loadMap","source","data","Object","create","keys","forEach","k","cov","CoverageMap","obj","prototype","merge","other","fc","filter","callback","toJSON","files","fileCoverageFor","file","Error","addFileCoverage","path","getCoverageSummary","ret","key","toSummary","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst FileCoverage = require('./file').FileCoverage;\nconst CoverageSummary = require('./file').CoverageSummary;\n\nfunction loadMap(source) {\n    const data = Object.create(null);\n    Object.keys(source).forEach(k => {\n        const cov = source[k];\n        if (cov instanceof FileCoverage) {\n            data[k] = cov;\n        } else {\n            data[k] = new FileCoverage(cov);\n        }\n    });\n    return data;\n}\n/**\n * CoverageMap is a map of `FileCoverage` objects keyed by file paths.\n * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n * map's contents. This can be the raw global coverage object.\n * @constructor\n */\nfunction CoverageMap(obj) {\n    if (!obj) {\n        this.data = Object.create(null);\n    } else if (obj instanceof CoverageMap) {\n        this.data = obj.data;\n    } else {\n        this.data = loadMap(obj);\n    }\n}\n/**\n * merges a second coverage map into this one\n * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n *  correctly for the same files and additional file coverage keys are created\n *  as needed.\n */\nCoverageMap.prototype.merge = function(obj) {\n    let other;\n    if (obj instanceof CoverageMap) {\n        other = obj;\n    } else {\n        other = new CoverageMap(obj);\n    }\n    Object.keys(other.data).forEach(k => {\n        const fc = other.data[k];\n        if (this.data[k]) {\n            this.data[k].merge(fc);\n        } else {\n            this.data[k] = fc;\n        }\n    });\n};\n/**\n * filter the coveragemap based on the callback provided\n * @param {Function (filename)} callback - Returns true if the path\n *  should be included in the coveragemap. False if it should be\n *  removed.\n */\nCoverageMap.prototype.filter = function(callback) {\n    Object.keys(this.data).forEach(k => {\n        if (!callback(k)) {\n            delete this.data[k];\n        }\n    });\n};\n/**\n * returns a JSON-serializable POJO for this coverage map\n * @returns {Object}\n */\nCoverageMap.prototype.toJSON = function() {\n    return this.data;\n};\n/**\n * returns an array for file paths for which this map has coverage\n * @returns {Array{string}} - array of files\n */\nCoverageMap.prototype.files = function() {\n    return Object.keys(this.data);\n};\n/**\n * returns the file coverage for the specified file.\n * @param {String} file\n * @returns {FileCoverage}\n */\nCoverageMap.prototype.fileCoverageFor = function(file) {\n    const fc = this.data[file];\n    if (!fc) {\n        throw new Error('No file coverage available for: ' + file);\n    }\n    return fc;\n};\n/**\n * adds a file coverage object to this map. If the path for the object,\n * already exists in the map, it is merged with the existing coverage\n * otherwise a new key is added to the map.\n * @param {FileCoverage} fc the file coverage to add\n */\nCoverageMap.prototype.addFileCoverage = function(fc) {\n    const cov = new FileCoverage(fc);\n    const path = cov.path;\n    if (this.data[path]) {\n        this.data[path].merge(cov);\n    } else {\n        this.data[path] = cov;\n    }\n};\n/**\n * returns the coverage summary for all the file coverage objects in this map.\n * @returns {CoverageSummary}\n */\nCoverageMap.prototype.getCoverageSummary = function() {\n    const ret = new CoverageSummary();\n    this.files().forEach(key => {\n        ret.merge(this.fileCoverageFor(key).toSummary());\n    });\n    return ret;\n};\n\nmodule.exports = {\n    CoverageMap\n};\n"]},"metadata":{},"sourceType":"script"}